<!DOCTYPE html>
<html>
  	<head>
		<link rel="icon" href="favicon.ico">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Tectonics simulator</title>
		<style>
			body {
				margin: 0;
				font-family: Arial, Helvetica, sans-serif;
				color:rgb(255, 255, 255);
				overflow: hidden;
				background: #222;
			}
			#container {
				position: relative;
			}			
			#help {
				position: absolute;
				bottom: 0;
				left: 0;
				margin: 5px;
			}


			/* unvisited link */
			a:link {
				color: #bada55;
				text-decoration: none;
			}
			/* visited link */
			a:visited {
				color: #bada55;
				text-decoration: none;
			}
			/* mouse over link */
			a:hover {
				color: #bada55;
				text-decoration: underline;
			}
			/* selected link */
			a:active {
				color: #bada55;
				text-decoration: underline;
			}


			/* Dropdown controls */

			/* Remove default bullets */
			ul, #myUL {
				list-style-type: none;
				padding-left: 10px;
			}
			
			/* Remove margins and padding from the parent ul,
			and set it floating top left over canvas */
			#myUL {
				margin: 5px;
				padding: 10px;
				position: absolute;
				top: 0;
				left: 0;
				background-color: rgba(0,0,0,0.5);
				border-radius: 10px;
			}

			/* Style the caret/arrow */
			.caret {
				cursor: pointer;
				user-select: none; /* Prevent text selection */
			}

			/* Create the caret/arrow with a unicode, and style it */
			.caret::before {
				content: "\25B6";
				color: rgb(255, 255, 255);
				display: inline-block;
				margin-right: 6px;
			}

			/* Rotate the caret/arrow icon when clicked on (using JavaScript) */
			.caret-down::before {
				transform: rotate(90deg);
			}

			/* Hide the nested list */
			.nested {
				display: none;
			}

			/* Show the nested list when the user clicks on the caret/arrow (with JavaScript) */
			.active {
				display: block;
			}
			

			/* Checkboxes */
			/* from https://codepen.io/JAGATHISH1123/embed/PvayMB?default-tab=&theme-id= */
			.switch {
			position: relative;
			display: inline-block;
			width: 32px;
			height: 16px;
			background-color: rgba(255, 255, 255, 0.25);
			border-radius: 16px;
			transition: all 0.3s;
			}
			.switch::after {
			content: '';
			position: absolute;
			width: 12px;
			height: 12px;
			border-radius:50%;
			background-color: white;
			top: 2px;
			left: 2px;
			transition: all 0.3s;
			}

			.checkbox:checked + .switch::after {
			left : 16px;
			}
			.checkbox:checked + .switch {
			background-color: #bada55;
			}
			.checkbox {
			display : none;
			}



			/* SLIDERS */
			/* The slider itself */
			.slider {
			-webkit-appearance: none;  /* Override default CSS styles */
			appearance: none;
			width: 100px;
			height: 16px;
			border-radius: 8px;
			background: rgba(255, 255, 255, 0.25);
			}

			/* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */
			.slider::-webkit-slider-thumb {
			-webkit-appearance: none; /* Override default look */
			appearance: none;
			width: 12px;
			height: 12px;
			border-radius: 6px;
			background: #bada55;
			cursor: pointer;
			}
			.slider::-moz-range-thumb {
			width: 12px;
			height: 12px;
			border-radius: 6px;
			background: #bada55;
			cursor: pointer;
			}
			output {
			color: #bada55;
			}
		</style>
  	</head>
  	<body>
		<div id="container">
			<canvas id="myCanvas">
				<p>This browser doesn't support canvas.</p>
			</canvas>
			<ul id="myUL">
				<li><span class="caret">Controlli</span>
				  	<ul class="nested">
						<li>
							<input type="checkbox" id="start" class="checkbox" />  
							<label for="start" class="switch"></label>
							Avvia
						</li>
						<li>
							<input type="checkbox" id="paint" class="checkbox" />  
							<label for="paint" class="switch"></label>
							Disegna
							<select id="brush">
								<option value="air">Aria</option>
								<option value="sedimentary">Sedimentarie</option>
								<option value="magmatic">Magmatiche</option>
								<option value="metamorphic">Metamorfiche</option>
								<option value="magma">Magma</option>							
							</select>
						</li>
						<li>
							Velocit√†:<br />
							<input type="range" min="0" max="10" value="1" step="1" class="slider" id="speed" oninput="speedoutput.value = value"/>
							<output id="speedoutput">1</output>
						</li>
						<li>
							Mostra:
							<select id="view">
								<option value="rock type">Tipo di roccia</option>
								<option value="temperature">Temperatura</option>						
							</select>
						</li>
						<li>
							Variazione flusso termico:<br />
							<input type="range" min="-5" max="5" value="0" step="1" class="slider" id="thermal" oninput="thermaloutput.value = value"/>
							<output id="thermaloutput">0</output>
						</li>
				  	</ul>
				</li>
			</ul>
			<div id="help">
				<a href="help.html" target="_blank">Help & Credits</a>
			</div>
		</div>
	</body>
	<script>
		// Dropdown controls
		const toggler = document.getElementsByClassName("caret");

		for (let i = 0; i < toggler.length; i++) {
			toggler[i].addEventListener("click", function() {
				this.parentElement.querySelector(".nested").classList.toggle("active");
				this.classList.toggle("caret-down");
			});
		}
	</script>
    <script>
// Parameters
const nx = 30;
const ny = 30;
const wl = 20;
const sinkWidth = 10;
const mm = 3.3; // Magma mass
const dPlimit = 1; // Minimum pressure difference to start a slidechain
const cdT = .01;

let matStack = []
for (let j = 0; j < 10; j++) {
	matStack[j] = "magma";
}
for (let j = 10; j < 16; j++) {
	matStack[j] = "magmatic";
}
for (let j = 16; j < 18; j++) {
	matStack[j] = "sedimentary";
}
for (let j = 18; j < wl; j++) {
	matStack[j] = "water";
}
for (let j = wl; j < ny; j++) {
	matStack[j] = "air";
}

let TStack = []
for (let j = 0; j < ny; j++) {
	TStack[j] = 1.1 - j / wl * 0.1;
}

// Links to page elements
const canvas = document.getElementById("myCanvas");
const startBtn = document.getElementById("start");
const paintBtn = document.getElementById("paint");
const brush = document.getElementById("brush");
const speedSlider = document.getElementById("speed");
const view = document.getElementById("view");
const thermalSlider = document.getElementById("thermal");

// Set up canvas and context
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;
const ctx = canvas.getContext('2d');
let rx = width / nx;
let ry = height / ny;

class Particle {
	constructor(material, T) {
		this.material = material;
		this.T = ( material == "air" || material == "water" ) ? 1 : T;
		switch(material) {
			case "air":
				this.intdensity = 0;
				break;
			case "water":
				this.intdensity = 1;
				break;
			case "sedimentary":
				this.intdensity = 2;
				break;
			case "magmatic":
				this.intdensity = 2.7;
				break;
			case "metamorphic":
				this.intdensity = 2.7;
				break;
			case "magma":
				this.intdensity = mm;
				break;
		}
	}
	get density() {
		return( this.intdensity / this.T);
	}
	get color() {
		switch(view.value) {
			case "rock type":
				switch(this.material) {
					case "air":
						return("rgb(200, 200, 255)");
						break;
					case "water":
						return("rgb(0, 0, 255)");
						break;
					case "sedimentary":
						return("rgb(255, 200, 0)");
						break;
					case "magmatic":
						return("rgb(200, 100, 0)");
						break;
					case "metamorphic":
						return("rgb(200, 0, 100)");
						break;
					case "magma":
						return("rgb(200, 0, 0)");
						break;
				}
				break;
			case "temperature":
				return("rgb(" + ( ( this.T - 1 ) * 1500 + 100 ) + ", 0, 0)");
				break;
		}
		
	}
}

// Define the grid that will contain the particle objects
let grd = new Array(nx);
for(let i = 0; i < nx; i ++) grd[i] = new Array(ny);

// Define the pressure grid
let LeftBorderP = new Array(ny);
let RightBorderP = new Array(ny);
let BottomP = new Array(nx);
let P = new Array(nx);
for(let i = 0; i < nx; i ++) {
	P[i] = new Array(ny);
}
let bp = [];

drawCanvas = function() {
	ctx.fillStyle = "black";
	ctx.fillRect( 0, 0, width, height );
	
	for(let i = 0; i < nx; i ++) {
		for(let j = 0; j < ny; j ++) {
			ctx.fillStyle = grd[i][j].color;
			ctx.fillRect(i * rx, height - ( j + 1 ) * ry, rx, ry);
		}
	}
}

function init() {
	for(let i = 0; i < nx; i ++) {
		for(let j = 0; j < ny; j ++) {
			grd[i][j] = new Particle( matStack[j], TStack[j] );
		}
	}

	LeftBorderP[ny-1] = 0;
	for(let j = ny - 2; j > -1; j --) {
		LeftBorderP[j] = LeftBorderP[j+1] + grd[0][j+1].density;
	}

	RightBorderP[ny-1] = 0;
	for(let j = ny - 2; j > -1; j --) {
		RightBorderP[j] = RightBorderP[j+1] + grd[nx - 1][j+1].density;
	}

	for (let i = 0; i < nx; i++) {
		bp[i] = LeftBorderP[0] + grd[0][0].density;
	}
	
	
	drawCanvas();
}

function raiseColumn(x, y) {
	for(let j = ny - 1; j > y; j --) {
		grd[x][j] = grd[x][j - 1];
	}
}

function slidechain(x, y) {
	let i = 0;

	for (i = 0; i < nx * ny + 1; i++) {
		const leftP = x == 0 ? LeftBorderP[y] + speedSlider.value : P[x - 1][y];
		const rightP = x == nx - 1 ? RightBorderP[y] + speedSlider.value : P[x + 1][y];
		const thisP = P[x][y];

		if (leftP > rightP && leftP > thisP) {
			
			if (x == 0) { 
				grd[x][y] = new Particle(matStack[y], TStack[y]); 
				break;
			} else {
				grd[x][y] = grd[x - 1][y];
				x = x - 1;
			}
		} else if ( rightP > leftP && rightP > thisP ) {
			if (x == nx - 1) { 
				grd[x][y] = new Particle(matStack[y], TStack[y]); 
				break;
			} else {
				grd[x][y] = grd[x + 1][y];
				x = x + 1;
			}
		} else {
			if (thisP == 0) { 
				grd[x][y] = new Particle("air", TStack[y]);
				break;
			} else {
				grd[x][y] = grd[x][y + 1];
				y = y + 1;
			}
		}
	}

	if (i == nx * ny + 1) { throw 'Too many iterations in slidechain, endend on ' + x + ' ' + y; }

	
}

function loop() {
	if(startBtn.checked) {

		//Update cycle

		//Check hanging particles
		for(let i = 0; i < nx; i ++) {
			for(let j = 1; j < ny; j ++) {
				if(
					grd[i][j].material != "air" 
					&& grd[i][j].material != "water"
					&& ( grd[i][j-1].material == "air" || grd[i][j-1].material == "water" )
				) {
					let mat = grd[i][j-1].material;
					grd[i][j-1] = grd[i][j];
					grd[i][j] = new Particle(mat, 1);
				}
			}
		}

		//Fill with water
		for(let i = 0; i < nx; i ++) {
			for(let j = 0; j < wl; j ++) {
				if(	grd[i][j].material == "air" ) {	grd[i][j] = new Particle("water", 1); }
			}
			for(let j = wl; j < ny; j ++) {
				if(	grd[i][j].material == "water" ) {	grd[i][j] = new Particle("air", 1); }
			}
		}

		// Heat exchange
		let dT = [];
		for ( let i = 0; i < nx; i++ ) {
			dT[i] = [];
			for ( let j = 0; j < ny; j ++ ) {
				dT[i][j] = 0;
			}
		}
		for ( let i = 0; i < nx; i++ ) {

			// Heat flux from interior
			dT[i][0] += 0.1 / wl;
			if ( i > nx * 3 / 7 && i < nx * 4 / 7 ) { dT[i][0] += 0.1 * thermalSlider.value; }

			// Heat exchange between particles
			for ( let j = 0; j < ny; j ++ ) {
				if ( i < nx - 1 ) { 
					dT[i][j] += grd[i + 1][j].T - grd[i][j].T;
					dT[i + 1][j] -= grd[i + 1][j].T - grd[i][j].T;
				 }
				 if ( j < ny - 1 ) { 
					dT[i][j] += grd[i][j + 1].T - grd[i][j].T;
					dT[i][j + 1] -= grd[i][j + 1].T - grd[i][j].T;
				 }
			}
		}
		for ( let i = 0; i < nx; i++ ) {
			for ( let j = 0; j < ny; j ++ ) {
				if ( grd[i][j].material != "air" && grd[i][j].material != "water" ) {
					grd[i][j].T += dT[i][j] * cdT * speedSlider.value;
				}
			}
		}

		// Calculate pressures
		for(let i = 0; i < nx; i ++) {
			P[i][ny-1] = 0;
			for(let j = ny - 2; j > -1; j --) {
				P[i][j] = P[i][j+1] + grd[i][j+1].density;
			}
			BottomP[i] = P[i][0] + grd[i][0].density;
		}

		// Calculate pressure differences
		
		let dP = []
		dP[0] = [];
		// Left border
		for(let j = 0; j < ny; j++) {
			dP[0][j] = LeftBorderP[j] - P[0][j];
		}
		// Internal
		for(let i = 1; i < nx; i ++) {
			dP[i] = [];
			for(let j = 0; j < ny; j++) {
				dP[i][j] = P[i-1][j] - P[i][j];
			}
		}
		// Right border
		dP[nx] = [];
		for(let j = 0; j < ny; j++) {
			dP[nx][j] = P[nx - 1][j] - RightBorderP[j];
		}

		// Bottom
		let BottomdP = [];
		for(let i = 0; i < nx; i ++) {
			BottomdP[i] = bp[i] - BottomP[i];
		}

		// Find maximum pressure difference
		let maxBdPv = 0;
		let maxHdPv = 0;

		let maxBdPi = -1;
		let maxHdPi = [];

		for(let i = 0; i < ny; i++) {
			if ( Math.abs(BottomdP[i]) > Math.abs(maxBdPv) ) {
				maxBdPv = BottomdP[i];
				maxBdPi = i;
			}
		}

		for(let i = 0; i < nx + 1; i++) {
			for(let j = 0; j < ny; j++) {
				if ( Math.abs(dP[i][j]) > Math.abs(maxHdPv) ) {
					maxHdPv = dP[i][j];
					maxHdPi = [i, j];
				}
			}
			
		}

		let maxdPv = maxBdPv;
		let maxdPi = true;

		if ( Math.abs(maxHdPv) > Math.abs(maxdPv) ) {
			maxdPv = maxHdPv;
			maxdPi = false;
		}

		

		// Move the first particle and start the slidechain
		if (Math.abs(maxdPv) > dPlimit) {
			if (maxdPi) {
				if (maxdPv > 0) {
					raiseColumn(maxBdPi, 0);
					grd[maxBdPi][0] = new Particle("magma", TStack[0]);
				} else {
					slidechain(maxBdPi, 0);					
				}
			} else {
				if (maxdPv > 0) {
					if (maxHdPi[0] < nx) {
						raiseColumn(maxHdPi[0], maxHdPi[1]);
						slidechain(maxHdPi[0], maxHdPi[1]);
					} else {
						slidechain(maxHdPi[0] - 1, maxHdPi[1]);
					}
				} else {
					if (maxHdPi[0] > 0) {
						raiseColumn(maxHdPi[0] - 1, maxHdPi[1]);
						slidechain(maxHdPi[0] - 1, maxHdPi[1]);
					} else {
						slidechain(maxHdPi[0], maxHdPi[1]);
					}
				}
			}
		}

		



		drawCanvas();
	}

	requestAnimationFrame(loop);
}

// Resizer
function resizer() {	
	width = canvas.width = window.innerWidth;
	height = canvas.height = window.innerHeight;
	rx = width / nx;
	ry = height / ny;
	drawCanvas();
}
window.addEventListener('resize', resizer);

// Painter
let dragging = false;

function paintParticle(x, y) {
	grd[Math.floor(x / rx)][Math.floor(( height - y ) / ry )] = new Particle(brush.value, TStack[Math.floor(( height - y ) / ry )]);
	drawCanvas();
}

canvas.onmousedown = function(e) {
	if(paintBtn.checked) {
		paintParticle(e.offsetX, e.offsetY);
		dragging = true;
	}
}

canvas.onmousemove = function(e) {
	if(dragging) {
		paintParticle(e.offsetX, e.offsetY);
	}
}

view.onchange = function() {
	drawCanvas();
}

window.onmouseup = function() { dragging = false; }

init();

loop();

    </script>
</html>
